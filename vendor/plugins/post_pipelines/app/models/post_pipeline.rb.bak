class PostPipeline < ActiveRecord::Base
  require 'app_config'
  belongs_to :pipeline_result
  belongs_to :sample
  belongs_to :reference_genome
  belongs_to :flow_cell_lane
  
  def current_user
    @current_user
  end
  def current_user=(cu)
    @current_user=cu
  end

  def stats_file
    project_name=self.sample.project.name
    sample_id=self.sample.id
    stats_file="#{project_name}.#{sample_id}.stats"
    File.join(working_dir,stats_file)
  end

  def stats
    return "no stats available (#{stats_file})" unless FileTest.readable?(stats_file)
    stats=File.read(stats_file)
  end

  @@type_names=['Tag Counting','RNA Seq']
  def self.type_names
    @@type_names
  end
  def type_name
    @@type_names[self.runtype]
  end

  @@qsub_writer_names=['write_tc_qsub_file','write_rna_qsub_file']


  def label
    "sample_#{sample_id}_fcl_#{flow_cell_lane_id}"
  end

  def qsub_params
    <<"QSUB_PARAMS"

#PBS -N #{label}
#PBS -m bea
#PBS -M #{current_user.email}
#PBS -o #{working_dir}/#{label}.out
#PBS -e #{working_dir}/#{label}.err
#PBS -l walltime=72:00:00

QSUB_PARAMS
  end
  
  ########################################################################
  # launch a pipeline by writing a qsub file and invoking it:
  def launch
    Dir.mkdir(working_dir) unless FileTest.directory?(working_dir)
    FileUtils.chmod 02777, working_dir # like chmod g+s

    # write one qsub file for each flow_cell_lane/pipeline_result of the sample:
    writer=self.method(@@qsub_writer_names[self.runtype]) # returns a list of qsub filenames
    qsub_files=self.sample.flow_cell_lanes.collect(&writer) # collect invokes &writer once for each element in the list (synonym for 'map')

    # call qsub one each of the qsub files:
    qsub_files.each do |qfile| 
      cmd="/usr/local/bin/qsub #{qfile}"
#      cmd="sudo -u solxabot /usr/local/bin/qsub #{qfile}"
      success=system(cmd)
      unless (success) 
        raise "#{sample.name_on_tube}: failed to launch via qsub (#{cmd}, #{$?})"
#      else
#        raise "output of #{cmd}: '#{output}'"
      end

      
    end
  end

  # get the pp's sample object; shouldn't this method have been created via the belongs_to declaration????
  def sample
    Sample.find(self.sample_id)
  end

  def get_sample_params!(sample)
    ref_gen=sample.reference_genome
    self.sample_id=sample.id
    self.ref_genome_path=ref_gen.fasta_path # fixme: need to change this to our own genomes, or change existing db
    self.org_name=ref_gen.organism.name
    self
  end

  def get_pipeline_result_params!(flow_cell_lane)
    # get the most recent pipeline_result object for this fcl:
    pipeline_result=PipelineResult.find(:all, :conditions=>{:flow_cell_lane_id=>flow_cell_lane.id}, 
                                        :order=>'updated_at ASC',:limit=>1)[0]
    if (pipeline_result.nil?)
      raise "no pipeline_result w/id=#{flow_cell_lane.id}"
    else
      self.flow_cell_lane_id=flow_cell_lane.id
      self.pipeline_result_id=pipeline_result.id
      self.working_dir=File.dirname(pipeline_result.eland_output_file)+'/post_pipeline'
#      self.working_dir='/users/vcassen/software/Solexa/qsub_output/sandbox'
      self.export_file=pipeline_result.eland_output_file
    end
    self
  end

  ########################################################################

  # write out one qsub file for each flow_cell_lane (which has one pipeline_results object):
  # return the filename written
  def write_tc_qsub_file(flow_cell_lane)
    script_dir=File.join(AppConfig.plugin_dir,'qsub_files') # AppConfig methods throw exceptions if not defined
    tc_script=AppConfig.tc_script
    genomes=''                  # fixme: implement this: needs to look something like:
    # -genome_id=6 -genome_id=15
    
    script_contents=<<"QSUB"
#!/bin/sh
#{qsub_params}

perl #{RAILS_ROOT}/#{script_dir}/#{tc_script} -ssid=#{sample.id} -flowcell_id=#{flow_cell_lane.id} #{genomes}
QSUB

    return write_qsub_file(script_contents)
  end

  ########################################################################
  # Write an RNA-seq file using the template
  def write_rna_qsub_file(flow_cell_lane)

    pp_id=id
    ref_genome=get_rnaseq_ref_genome().name
    dryrun=1                    # fixme: reset to 0
    launch=dryrun>0? 'echo dryrun':''
    erccs=''
    email=current_user.email
    script_dir=AppConfig.script_dir
    rnaseq_dir="#{script_dir}/#{AppConfig.rnaseq_dir}"
    format=AppConfig.fasta_format
    jdrf_dir=AppConfig.jdrf_dir
    bowtie_opts=AppConfig.bowtie_opts
    genomes_dir="#{jdrf_dir}/genomes"
    reads_file="#{self.working_dir}/#{self.export_file}.#{format}"
    bowtie_output="#{reads_file}.#{AppConfig.bowtie_output_suffix}"
    rds_dir="#{working_dir}/rds"
    gene_models="#{genomes_dir}/#{org_name}/knownGene.txt"
    rds_output="#{rds_dir}/#{export_file}.rds"
    rds_args="-RNA #{gene_models} #{AppConfig.rds_args}"
    
    qsub_template=File.join(AppConfig.plugin_dir,'qsub_files',AppConfig.rna_seq_template)
    old_irs=$/
    $/="this is a very unlikely string to appear in the template"
    template='';
    File.open(qsub_template) {|file| template=file.gets } # slurp!
    $/=old_irs
    script=eval template

    return write_qsub_file(script)
  end


  def write_qsub_file(script)
    qsub_file="#{working_dir}/#{label}.qsub"
    FileUtils.mkdir_p working_dir unless FileTest.directory? working_dir
    File.open(qsub_file, "w") {|file| file.puts script }
    return qsub_file
  end


  def get_rnaseq_ref_genome
    # so we actually use the refereence_genome_id as a key into a different table.
    RnaSeqRefGenome.find(reference_genome_id)
  end

end
