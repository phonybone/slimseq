"#!/bin/sh

#PBS -N #{label}
#PBS -m bea
#PBS -M #{email}
#PBS -o #{working_dir}/#{label}.out
#PBS -e #{working_dir}/#{label}.err
#PBS -l walltime=72:00:00

dryrun=#{dryrun}
if [ $dryrun ]; then
    launch='echo dryrun'
else
    launch=
fi


# input args:
# Note: if running from qsub, no args are allowed.  So anything labeled as 'arg' must actually be written
# into the script, template fasion.  OR, you have the qsub script call this script, and write the args
# into the qsub script

# should be able to get all of the following using the pp_id and slimseq
working_dir=#{working_dir}
export_filepath=#{export_file}

# the only reason we even bother with base_dir is legacy; I really don't think we need it anymore???
base_directory=`dirname $export_filepath`
if [ "$base_directory" != "$working_dir" ]; then
  echo base_directory $base_directory
  echo working_dir    $working_dir
  echo not the same
  exit 1
fi

echo '*****************************************************'
echo writing output to:
echo $working_dir
echo '*****************************************************'
echo 

pp_id=#{pp_id}
ref_genome=#{ref_genome}
org=#{org_name}


if [ ! -r $export_filepath ]; then
  echo ${export_filepath}: no such file or unreadable
  exit 1
fi
export_file=`basename $export_filepath`
format='faq'

if [ ! -d $working_dir ]; then
    mkdir $working_dir 
    mkdir $working_dir/rds
fi

# config:
script_dir=/users/vcassen/software/Solexa
rnaseq_dir=$script_dir/RNA-Seq
bowtie_exe=$rnaseq_dir/bowtie/bowtie
erange_dir=$rnaseq_dir/commoncode

jdrf_dir=/jdrf/data_var/solexa
genomes_dir=$jdrf_dir/genomes

post_slimseq=$script_dir/post_to_slimseq.pl # needs pp_id and status

########################################################################
## translate export.txt file to fasta format

export2fasta=/tools/bin/fq_all2std.pl
cmd=\"perl $export2fasta export2std $base_directory/$export_file\"
echo \"translation cmd: $cmd\"
if [ $pp_id ]; then
  perl $post_slimseq -type post_pipelines -id $pp_id -field status -value 'extracting reads from ELAND file'
fi

# unlink converted export file if it exists (so that redirection, below, won't fail)
if [ -r $working_dir/$export_file.$format ]; then
  unlink $working_dir/$export_file.$format	
fi

$launch $cmd > $working_dir/$export_file.$format
# this writes $working_dir/$export_file.$format

########################################################################
## bowtie-cmd.sh:
## Note: bowtie needs .ewbt files to work from; don't exist yet for critters other than mouse

# reads_file is the input
reads_file=$working_dir/$export_file.$format	# export file converted to fasta format
repeats=$reads_file.repeats.$format
unmapped=$reads_file.unmapped.$format
bowtie_output=$reads_file.bowtie.out

export BOWTIE_INDEXES=\"$genomes_dir/$org\"

cmd=\"$bowtie_exe $ref_genome -v 2 -k 11 -m 10 -t --best -q $reads_file --unfa $unmapped --maxfa $repeats $bowtie_output\"
echo \"alignment cmd: $cmd\"
if [ $pp_id ]; then
  perl $post_slimseq -type post_pipelines -id $pp_id -field status -value 'aligning reads (bowtie)'
fi
$launch $cmd

echo $bowtie_output written
echo

#check
########################################################################
## makeRdsFromBowtie-cmd.sh:

# args:
label=label			  # arg; fixme

python=/tools/bin/python
script=$erange_dir/makerdsfrombowtie.py

# this is where the output (rds files) will go
rds_dir=$working_dir/rds

# from bowtie-cmd.sh:
input=$bowtie_output
output=$rds_dir/$export_file.rds

gene_models=$genomes_dir/$org/knownGene.txt
args=\"-RNA $gene_models -index -cache 1000 -rawreadID\"

cmd=\"$python $script $label $input $output $args\"
echo \"rds cmd: $cmd\"

echo $output written
echo
if [ $pp_id ]; then
  perl $post_slimseq -type post_pipelines -id $pp_id -field status -value 'Creating RDS files from alignment'
fi
$launch $cmd

########################################################################
## runStandardAnalysisNFS-cmd.sh:

echo erange cmd: $erange_dir/runStandardAnalysisNFS.sh $org $working_dir/rds/$export_file $jdrf_dir/genomes/mouse/repeats_mask.db 5000
if [ $pp_id ]; then
  perl $post_slimseq -type post_pipelines -id $pp_id -field status -value 'running ELAND'
fi
$launch time sh $erange_dir/runStandardAnalysisNFS.sh $org $working_dir/rds/$export_file $jdrf_dir/genomes/mouse/repeats_mask.db 5000

erccs=#{erccs}
if [ $erccs ]; then
# ERCC section copied from ~vcassen/software/Solexa/RNA-seq/ERCC/ercc_pipeline.qsub
########################################################################
# count ERCC alignments, utilizing original counts:
  bowtie2count=$script_dir/bowtie2count.ercc.pl
  ercc_counts=$working_dir/$export_file.ercc.counts # output 

  if [ ! -r $bowtie_output ]; then
    echo $bowtie_output unreadable
    exit 1
  fi

  cmd=\"$perl $bowtie2count $bowtie_output > $ercc_counts\"
  echo $cmd
  $launch $cmd
  echo $ercc_counts written 

########################################################################
# get total aligned reads by reading the file ${bowtie_output}.total_aligned_reads.
# This file is generated by bowtie2count in the previous step
  tarf=\"${bowtie_output}.total_aligned_reads\"
  if [ ! -r $tarf ]; then
    echo $tarf unreadable
    exit 1
  fi
  total_aligned_reads=`cat $tarf | cut -f2 -d:`
  if [ -z $total_aligned_reads -o $total_aligned_reads -eq 0 ]; then
    echo Unable to get valid read from $tarf
    exit 1
  fi

  echo total_aligned_reads: $total_aligned_reads

########################################################################
# normalize read counts:
  normalize_erccs=$script_dir/normalize_erccs.pl
  cmd=\"$perl $normalize_erccs -bowtie_output $bowtie_output -total_aligned_reads $total_aligned_reads -force\"
  # writes to $bowtie_output.normalized (sorta; removes old suffix first, ie, 'out'->'normalized').
  echo $cmd
  $launch $cmd

fi				# end ERCC section

########################################################################
## Stats:

echo gathering stats...

if [ $pp_id ]; then
  perl $post_slimseq -type post_pipelines -id $pp_id -field status -value 'generating stats'
fi

final_rpkm_file=$working_dir/rds/$export_file.final.rpkm
n_genes=`wc -l $final_rpkm_file | cut -f1 -d\  `

stats_file=$working_dir/stats
$stats=<<EOF
total aligned reads: $aligned_reads
number of genes observed: $n_genes
EOF

if [ $pp_id ]; then
  perl $post_slimseq -type post_pipelines -id $pp_id -field stats_file -value '$working_dir/stats'
  perl $post_slimseq -type post_pipelines -id $pp_id -field status -value 'Finished'
fi
"
